The ZeroMQ Message Transport Protocol (ZMTP) is a transport layer protocol for exchanging messages between two peers over a connected transport layer such as TCP. This document describes ZMTP/3.0. The major change in this version is the addition of security mechanisms and the removal of connection properties (socket type and identity).

* Name: rfc.zeromq.org/spec:23/ZMTP
* Editor: Pieter Hintjens <ph@imatix.com>
* Contributors: Martin Hurton <mh@imatix.com>
* State: raw

++ License

Copyright (c) 2009-2013 iMatix Corporation

This Specification is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.

This Specification is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses>.

++ Change Process

This Specification is a free and open standard[((bibcite fandos))] and is governed by the Digital Standards Organization's Consensus-Oriented Specification System (COSS)[((bibcite coss))].

++ Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119[((bibcite rfc2119))].

++ Goals and Overall Behavior

The ZeroMQ Message Transport Protocol (ZMTP) is a transport layer protocol for exchanging messages between two peers over a connected transport layer such as TCP. This document describes ZMTP/3.0. The changes in this version of the specification are a new version numbering scheme, the addition of security mechanisms, and the removal of connection properties (socket type and identity) from the greeting.

A ZMTP/3.0 connection goes through these stages:

* The two peers greet each other.
* The peers handshake a security mechanism.
* The peers exchange connection properties.
* The peers use the connection to send data.

A ZMTP/3.0 connection //always// uses a security mechanism. The protocol allows the use of arbitrary mechanisms, for future extensibility and experimentation. ZMTP/3.0 specifies two mechanisms: PLAIN (simple authentication over clear text) and CURVE (secure authentication and confidentiality).

++ Implementation

+++ Formal Grammar

The following ABNF grammar defines the ZMTP/3.0 protocol:

[[code]]
zmtp        = *connection

connection  = greeting *message

greeting    = signature major minor mechanism
signature   = %xFF padding %x7F
padding     = 8%x00       
major       = %x03        ; Version number major
minor       = %x00        ; Version number minor
mechanism   = 20OCTET     ; Null-padded string

message     = *more-frame final-frame
final-frame = final body
final       = final-short | final-long
final-short = %x00 OCTET
body        = *OCTET
final-long  = %x02 8OCTET
more-frame  = more body
more        = more-short | more-long
more-short  = %x01 OCTET            
more-long   = %x03 8OCTET           
[[/code]]

+++ The Greeting

Each peer starts by sending a fixed 10 octet protocol signature (%xFF 8%x00 %x7F), followed by a two octet version number (%x03 %x00), followed by a 20 octet security mechanism (a null-filled ASCII string of 1 to 20 characters).

The signature has an 8-byte padding field. A peer SHOULD place zeroes into this field but MAY place other values. A peer MUST NOT validate this padding value and MAY NOT interpret it in any way whatsoever.

ZMTP/3.0 uses an extensible security model loosely based on the Simple Authentication and Security Layer (SASL)[((bibcite rfc4422))]. All connections use a security mechanism. A ZMTP/3.0 implementation SHOULD support at least these two security mechanisms:

* "ZMTP-PLAIN", specified by rfc.zeromq.org/spec:24/ZMTP-PLAIN, which implements a clear-text user/password mechanism.

* "ZMTP-CURVE", specified by rfc.zeromq.org/spec:25/ZMTP-CURVE, which implements the CurveZMQ security handshake[((bibcite curvezmq))].

ZMTP/3.0 offers no negotiation of the security mechanisms. The security mechanism can be considered //assertive// in that once a connection is established, a peer is certain that all incoming messages have the required level of security. This prevents downgrade attacks and simplifies implementations.

A greeting received from the other peer is considered "invalid" if it does not match exactly the greeting sent to the peer. That is, the same signature (except for padding), version number, and security mechanism.

A ZMTP/3.0 peer (except for working with older protocol versions) MUST treat an invalid greeting as fatal and SHOULD close the connection after a random delay. A connecting peer that receives an invalid greeting SHOULD NOT reconnect.

To detect and interoperate with older ZMTP protocol implementations, we use the strategy of selectively imitating the older protocol. Future interoperability is based on this same strategy (applied backwards to this version of ZMTP). We discuss backwards interoperability at the end of this document.

+++ Messages and Frames

ZMTP/3.0 delimits the TCP stream following the greeting into //messages//. A message consists of one or more //frames// for purposes of structuring. A frame consists of a flags field (1 octet), followed by a length field (1 or 8 octets) and a frame body of length octets. The length does not include the flags field, nor itself, so an empty frame has a length of zero.

The flags field consists of a single octet containing various control flags. Bit 0 is the least significant bit (rightmost bit):

* Bit 0 (MORE): //More frames to follow//. A value of 0 indicates that there are no more frames to follow. A value of 1 indicates that more frames will follow. On messages consisting of a single frame the MORE bit MUST be 0.

* Bit 1 (LONG): //Long message//. A value of 0 indicates that the message length is encoded as a single octet. A value of 1 indicates that the message length is encoded as a 64-bit unsigned integer in network byte order.

* Bits 2-7: //Reserved//. Bits 2-7 are reserved for future use and MUST be zero.

The following diagram shows the layout of a final data frame with a length of 0 to 255 octets:

[[code]]
            +-----------------+
 Octet 0    | 0 0 0 0 0 0 0 0 |
            +-----------------+
 Octet 1    | Length          |
            +-----------------+- ... -----------------+
 Octets 2+  | Body                      Length octets |
            +------------------- ... -----------------+
[[/code]]

The following diagram shows the layout of a final LONG data frame:

[[code]]
            +-----------------+
 Octet 0    | 0 0 0 0 0 0 1 0 |
            +-----------------+
 Octets 1-8 | Length                       8 octets   |
            +------------------ ... ------------------+
 Octets 9+  | Body                      Length octets |
            +------------------ ... ------------------+
[[/code]]

+++ Security Handshake

The security handshake consists of zero or more messages sent between the peers. The precise nature of this handshake depends on the security mechanism.

+++ Connection Properties

Following successful security handshaking, the peer SHALL send, and SHALL expect, a single message containing the connection properties. This message may be encrypted according to the security mechanism. In its clear text form, it SHALL be formatted as a list of name-value pairs where each pair consists of a printable name, followed by '=', followed by a printable string value, followed by a null octet.

All implementations SHALL provide at least these properties:

* "SOCKET-TYPE", which specifies the sender's socket type, as one of "PAIR", "XPUB", "XSUB", "REQ", "REP", "DEALER", "ROUTER", "PULL", or "PUSH".
* "IDENTITY", which specifies the sender's socket identity, encoded as a hex string.

An implementation MAY validate socket types and identities. The implementation MUST ignore any property that it does not recognize.

The implementation MAY enforce that an incoming connection has a valid socket type, depending on the socket type of the socket receiving the connection:

* PAIR accepts connections from PAIR.
* PUB accepts connections from SUB.
* SUB accepts connections from PUB.
* REQ accepts connections from REP or ROUTER.
* REP accepts connections from REQ or DEALER.
* DEALER accepts connections from REP, DEALER, or ROUTER.
* ROUTER accepts connections from REQ, DEALER, or ROUTER.
* PULL accepts connections from PUSH.
* PUSH accepts connections from PULL.

Any other socket combinations SHOULD be handled by silently disconnecting the other peer and possibly logging the error for debugging purposes.

+++ Using the Connection

Following the connection property message, each peer MAY send arbitrary messages. Either peer may close the connection at any point

+++ Error Handling

If the other peer closes the connection before sending a first data message, this SHOULD be treated as a permanent failure, i.e. the implementation SHOULD NOT reconnect automatically. If the other peer closes the connection after sending at least one data message, this SHOULD be treated as a temporary failure, and the implementation SHOULD reconnect after a suitable waiting period.

++ Backwards Interoperability

To detect and work with older versions of ZMTP, we use a mix of strategies. An implementation MAY use any or all or none of these strategies.

+++ Detecting ZMTP/2.0 Peers

From ZMTP/2.0[((bibcite zmtp20))] onwards, the protocol contains the version number immediately after the signature. To detect and interoperate with ZMTP/2.0 peers, the implementation SHALL:

* Send the 10-octet signature followed by the major version number (the single octet %x03).

* Wait for the other peer to send its greeting.

* If this has the version number 1 or 2, the peer is using ZMTP/2.0, so send the ZMTP/2.0 socket type and identity and continue with ZMTP/2.0.

* If this has the version number 3, the peer is using ZMTP/3.0, so send the rest of the greeting and continue with ZMTP/3.0.

+++ Detecting ZMTP/1.0 Peers

ZMTP/1.0[((bibcite zmtp10))] did not have any version information. To detect and interoperate with a ZMTP/1.0 peer, an implementation SHALL:

* Send a 10-octet pseudo-signature consisting of "%xFF length %x7F" where 'length' is the length of the sender's identity (0 or more octets) plus 1. The length MUST be 8 octets in network byte order and occupies the padding field.

* Read the first octet from the other peer.

* If this octet is not %FF, then the other peer is using ZMTP/1.0.

* If this octet is %FF, then we read nine further octets, and inspect the last octet (the 10th). If the least significant bit is 0, then the other peer is using ZMTP/1.0.

* If the least significant bit is not 0, the peer is using ZMTP/3.0 or a later version. We read a further octet, which indicates the protocol version. If this is 1 or 2, we have a ZMTP/2.0 peer. If this is 3, we have a ZMTP/3.0 peer.

* When we have detected a ZMTP/1.0 peer, we have already sent 10 octets, which the other peer interprets as the start of an identity frame. We continue by sending the body of the identity frame (zero or more octets). From then, we encode and decode all frames on that connection using the ZMTP/1.0 framing syntax.

++ References

[[bibliography]]
: rfc2119 : "Key words for use in RFCs to Indicate Requirement Levels" - [http://tools.ietf.org/html/rfc2119 ietf.org]
: rfc4422 : "Simple Authentication and Security Layer" - [http://tools.ietf.org/html/rfc4422 ietf.org]
: fandos : "Definition of a Free and Open Standard" - [http://www.digistan.org/open-standard:definition digistan.org]
: coss : "Consensus Oriented Specification System" - [http://www.digistan.org/spec:1/COSS digistan.org]
: zmtp10 : "13/ZMTP - ZeroMQ Message Transport Protocol" - [http://rfc.zeromq.org/spec:13 rfc.zeromq.org]
: zmtp20 : "15/ZMTP - ZeroMQ Message Transport Protocol" - [http://rfc.zeromq.org/spec:15 rfc.zeromq.org]
: curvezmq : "The CurveZMQ Secure Handshake" - [http://curvezmq.org curvezmq.org]
[[/bibliography]]

The ZeroMQ Message Transport Protocol (ZMTP) is a transport layer protocol for exchanging messages between two peers over a connected transport layer such as TCP. This document describes ZMTP/3.0. The major change in this version is the addition of security mechanisms and the removal of hard-coded connection metadata (socket type and identity) from the greeting.

* Name: rfc.zeromq.org/spec:23/ZMTP
* Editor: Pieter Hintjens <ph@imatix.com>
* Contributors: Martin Hurton <mh@imatix.com>
* State: draft

++ License

Copyright (c) 2009-2013 iMatix Corporation

This Specification is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.

This Specification is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses>.

++ Change Process

This Specification is a free and open standard[((bibcite fandos))] and is governed by the Digital Standards Organization's Consensus-Oriented Specification System (COSS)[((bibcite coss))].

++ Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119[((bibcite rfc2119))].

++ Goals

The ZeroMQ Message Transport Protocol (ZMTP) is a transport layer protocol for exchanging messages between two peers over a connected transport layer such as TCP. This document describes ZMTP/3.0. ZMTP/3.0 solves a number of problems we face when using TCP carry messages:

* TCP carries a stream of bytes with no delimiters, but we want to send and receive discrete messages. Thus, ZMTP reads and writes //frames// consisting of a size and a body.

* We need to carry metadata on each frame (such as, whether the frame is part of a multipart message, or not). ZMTP provides a //flags// field in each frame for metadata.

* We need to be able to talk to older implementations, so that our framing can evolve without breaking existing implementations. ZMTP defines a //greeting// that announces the implemented version number, and specifies a method for version negotiation.

* We want to avoid that each task must bind to a unique interface and port, since this increases system administration costs. ZMTP provides a //service// field in the greeting that lets any number of tasks bind to the same interface and port.

* We need security so that peers can be sure of the identity of the peers they talk to, and so that messages cannot be tampered with, nor inspected, by third parties. ZMTP defines a //security handshake// that allows peers to create a secure connection.

* We need a range of security protocols, from clear text (no security, but fast) to fully authenticated and encrypted (secure, but slow). Further, we need the freedom to add new security protocols over time. ZMTP defines a way for peers to agree on an extensible //security mechanism//.

* We need a way to carry metadata about the connection, after the security handshake. ZMTP defines a standard set of //metadata properties// (socket type, identity, etc.) that peers exchange after the security mechanism.

* We need to write down these solutions in a way that is easy for teams to implement on any platform and in any language. ZMTP is thus specified as a formal protocol (this document) and made available to teams under a free license.

* We need guarantees that people will not create private forks of ZMTP, thus breaking interoperability. ZMTP is thus licensed under the GPLv3, so that any derived versions must also be made available to users of software that implements it.

+++ Changes from Previous Versions

The changes in version 3 of the specification are a simpler version numbering scheme, the addition of security mechanisms, the removal of hard-coded connection metadata (socket type and identity) from the greeting, and the addition of connection metadata.

++ Implementation

+++ Overall Behavior

A ZMTP/3.0 connection goes through these main stages:

* The two peers agree on the version and security mechanism of the connection by sending each other data and either continuing the discussion, or closing the connection.

* The two peers handshake the security mechanism by exchanging zero or more commands. If the security handshake is successful, the peers continue the discussion, otherwise one or both peers closes the connection.

* Each peer then sends the other metadata about the connection as a final command. The peers may check the metadata and each peer decides either to continue, or to close the connection.

* Each peer is then able to send the other messages. Either peer may at any moment close the connection.

+++ Formal Grammar

The following ABNF grammar defines the ZMTP/3.0 protocol:

[[code]]
;   The protocol consists of zero or more connections
zmtp = *connection

;   Each connection consists of a greeting, zero or more commands
;   depending on the mechanism, and and zero or more messages
connection = greeting *command *message

;   The greeting announces the protocol details
greeting = signature version service options mechanism

signature = %xFF padding %x7F
padding = 8OCTET        ; Not significant

version = version-major version-minor
version-major = %x03            
version-minor = %x00

;   The service name is a null padded string
service = 120service-char
service-char = ALPHA | DIGIT
    | "$" | "-" | "_" | "@" | "." | "&" | "+" | %x0

;   The options are 8 octets
options = server-flag 7%x00
server-flag = %x00 | %x01

;   The mechanism is a null padded string
mechanism = 20mechanism-char
mechanism-char = "A"-"Z" | DIGIT
    | "-" | "_" | "." | "+" | %x0

;   A command is a single long or short frame
command = command-size frame-body
command-size = %x04 short-size | %x06 long-size
short-size = OCTET          ; Body is 0 to 255 octets
long-size = 8OCTET          ; Body is 0 to 2^63-1 octets
frame-body = *OCTET     

;   A message is 1 or more long or short frames
message = *message-more message-last
message-more = ( %x01 short-size | %x03 long-size ) frame-body
message-last = ( %x00 short-size | %x02 long-size ) frame-body
[[/code]]

+++ Version Negotiation

ZMTP/3.0 provides asymmetric version negotiation. A ZMTP/3.0 peer MAY attempt to detect and work with older versions of the protocol. It MAY also demand ZMTP/3.0 capabilities from its peers.

In the first case, after making or receiving a connection, the peer SHALL send to the other a partial greeting sufficient to trigger version detection. This is the first eleven (11) octets of the greeting (signature and major version number). The peer SHALL then read the first eleven octets of greeting sent by the other peer, and determine whether to downgrade or not. The specific heuristics for each older ZMTP version are explained in the section "Backwards Interoperability". In this case the peer MAY use the padding field for older protocol detection (we explain the specific known case below).

In the second case, after making or receiving a connection, the peer SHALL send its entire greeting (32 octets) and SHALL expect a matching 32 octet greeting. In this case the peer SHOULD set the padding field to binary zeroes.

In either case, note that:

* A peer SHALL NOT assign any significance to the padding field and MUST NOT validate this nor interpret it in any way whatsoever.

* A peer MUST accept higher protocol versions as valid. That is, a ZMTP/3.0 peer MUST accept protocol versions greater or equal to 3.0. This allows future implementations to safely interoperate with current implementations.

* A peer SHALL always use its own protocol (including framing) when talking to an equal or higher protocol peer.

* A peer MAY downgrade its protocol to talk to a lower protocol peer.

* If a peer cannot downgrade its protocol to match its peer, it MUST close the connection.

+++ Service Routing

ZMTP/3.0 supports internal routing of connections, similarly to the HTTP "Virtual Host" function. Service names are chosen by end user applications. Conceptually, the service name extends the endpoint used in a bind or connect API call, like this:

[[code]]
zmq_bind (publisher, "tcp://*:9001/service-name");
...
zmq_connect (subscriber, "tcp://192.168.55.23:9001/service-name");
[[/code]]

The service name may be empty.

+++ Topology

ZMTP/3.0 is by default a peer-to-peer protocol that makes no distinction between the clients and servers.

However, the security mechanisms (which are extension protocols, and explained below) MAY define distinct roles for client peers and server peers. This difference reflects the need to protect resources that tend to be concentrated on servers.

Traditionally in TCP topologies, the "server" is the peer which binds, and the "client" is the peer that connects. ZMTP/3.0 allows the opposite topology in which the client binds, and the server connects. This is specified in the greeting options server-flag field, which is set to 1 for server peers, and 0 for client peers.

If the chosen security mechanism does not specify a client and server topology, the server-flag field SHALL have no significance, and SHALL be zero for all peers.

The unused 7 octets in the options field are reserved for future use, and SHALL be zero.

+++ Authentication and Confidentiality

ZMTP/3.0 provides extensible authentication and confidentiality through the use of a negotiated security mechanism that is loosely based on the IETF Simple Authentication and Security Layer (SASL)[((bibcite rfc4422))]. The peer MAY support any or all of the following mechanisms:

* "NULL", specified later in this document, which implements no authentication, and no confidentiality.

* "PLAIN", specified by [http://rfc.zeromq.org/spec:24/ rfc.zeromq.org/spec:24/ZMTP-PLAIN], which implements simple user-name and password authentication, in clear text.

* "CURVE", specified by [http://rfc.zeromq.org/spec:25/ rfc.zeromq.org/spec:25/ZMTP-CURVE], which implements full authentication and confidentiality using the CurveZMQ security handshake[((bibcite curvezmq))].

The security mechanism is an ASCII string, null-padded as needed to fit 20 octets. Implementations MAY define their own mechanisms for experimentation and internal use. All mechanisms intended for public interoperability SHALL be defined as 0MQ RFCs. Mechanism names SHALL be assigned on a first-come first-served basis. Mechanism names SHALL consist only of uppercase letters A to Z, digits, and embedded hyphens or underscores.

A peer announces precisely one security mechanism, unlike SASL, which lets servers announce multiple security mechanisms. Security in ZMTP/3.0 is //assertive// in that all peers on a given socket have the same, required level of security. This prevents downgrade attacks and simplifies implementations.

Each security mechanism defines a protocol consisting of zero or more commands sent by either peer to the other until the handshaking is complete or either of the peers refuses to continue, and closes the connection. 

Commands are single frames consisting of a size field, and a body. If the body is 0-255 octets, the command SHOULD use a short size field (%x04 followed by 1 octet). If the body is 256 or more octets, the command SHOULD use a long size field (%x06 followed by 8 octets).

The size field is always in clear text. The body may be partially or fully encrypted. ZMTP/3.0 does not define the syntax nor semantics of commands. These are fully defined by the security mechanism protocol.

The supported mechanism is not considered sensitive information. A peer that reads a full greeting, including mechanism, MUST also send a full greeting including mechanism. This avoids deadlocks in which two peers each wait for the other to divulge the remainder of their greeting.

If the mechanism that the peer received does not exactly match the mechanism it sent, it MUST close the connection.

+++ Error Handling

ZMTP/3.0 has no explicit error responses. The peer SHALL treat all errors as fatal and act by closing the connection. When a peer sees that the other peer has closed the connection before the security handshake was complete, it SHALL NOT reconnect. If the other peer closes the connection after the security handshake was complete, the peer SHOULD reconnect.

To avoid connection storms, peers should reconnect after a short and possibly randomized interval. Further, if a peer reconnects more than once, it should increase the delay between reconnects. Various strategies are possible.

If a peer closes its connection before the connection was completed, this SHOULD be treated as a permanent failure, i.e. the implementation SHOULD NOT reconnect automatically.

If the peer closes its side of the connection after the connection was made successfully, this SHOULD be treated as a temporary failure, and the implementation SHOULD reconnect after a suitable waiting period.

In some cases there is no visible difference between an error disconnect and a normal disconnect. The peer MAY in such cases use timing as an indicator (an immediate disconnect is an error, a later disconnect is "normal").

+++ Connection Metadata

The security mechanism SHALL provide a way for peers to exchange metadata in the form of a key-value dictionary. The precise encoding of the metadata depends on the mechanism.

All implementations SHALL provide at least these metadata properties:

* "Socket-Type", which specifies the sender's socket type, as one of "PAIR", "XPUB", "XSUB", "REQ", "REP", "DEALER", "ROUTER", "PULL", or "PUSH".

* "Identity", which specifies the sender's socket identity, as an opaque binary blob of zero to 255 octets. If a peer does not send an identity value, the receiving peer SHALL assume the identity was empty (a zero-sized blob).

The peer MAY enforce that an incoming connection has a valid socket type, depending on the socket type of the socket receiving the connection:

* PAIR accepts connections from PAIR.
* PUB accepts connections from SUB.
* SUB accepts connections from PUB.
* REQ accepts connections from REP or ROUTER.
* REP accepts connections from REQ or DEALER.
* DEALER accepts connections from REP, DEALER, or ROUTER.
* ROUTER accepts connections from REQ, DEALER, or ROUTER.
* PULL accepts connections from PUSH.
* PUSH accepts connections from PULL.

If a peer validates the socket type, it SHOULD handle the error by silently disconnecting the other peer and possibly logging the error for debugging purposes.

The implementation MAY provide other metadata properties such as implementation name. For interoperability, metadata names and semantics MAY be defined as RFCs.

+++ Commands, Messages and Frames

Following the greeting, which has a fixed size of 160 octets, all further data is sent as size-specified frames. //Command frames// are used in the security handshake, and //message frames// are used to carry clear text application data. Commands always consist of a single frame. Messages consist of one or more frames. 

A frame consists of a flags field (1 octet), followed by a size field (1 or 8 octets) and a frame body of size octets. The size does not include the flags field, nor itself, so an empty frame has a size of zero.

A short frame has a body of 0 to 255 octets. A long frame has a body of 0 to 2^63-1 octets. The long size SHALL be in network byte order.

The flags field consists of a single octet containing various control flags. Bit 0 is the least significant bit (rightmost bit):

* Bits 7-3: //Reserved//. Bits 7-3 are reserved for future use and MUST be zero.

* Bit 2 (command): //command frame//. A value of 1 indicates that the frame is part of a command. A value of 0 indicates that the frame is part of a data message.

* Bit 1 (LONG): //Long frame//. A value of 0 indicates that the frame size is encoded as a single octet. A value of 1 indicates that the frame size is encoded as a 64-bit unsigned integer in network byte order.

* Bit 0 (MORE): //More frames to follow//. A value of 0 indicates that there are no more frames to follow. A value of 1 indicates that more frames will follow. This bit SHALL be zero on command frames.

++ Wire Analysis of the Connection

A ZMTP/3.0 connection is either clear text, or encrypted, according to the security mechanism. On a clear text connection, message data SHALL be sent as message frames. All clear text mechanisms SHALL use the message framing defined in this specification, so that wire analysis does not require knowledge of the specific mechanism.

On an encrypted connection, message data SHALL be encoded as commands so that wire analysis is not possible.

++ The NULL Security Mechanism

The NULL mechanism implements no authentication and no confidentiality. The NULL mechanism SHOULD NOT be used on public infrastructure without transport-level security (e.g. over a VPN).

To complete a NULL security handshake, both peers SHALL send each other a METADATA command. Both peers SHOULD then parse, and MAY validate the METADATA command. Either or both peer MAY then choose to close the connection if validation failed. A peer MAY start to send messages immediately after sending its metadata.

When a peer uses the NULL security mechanism, the server-flag field MUST be zero. The following ABNF grammar defines the NULL security handshake:

[[code]]
null = metadata *message
metadata = command-size "METADATA" *property
property = name value
name = OCTET *name-char
name-char = ALPHA | DIGIT | "-" | "_" | "." | "+"
value = 4OCTET *OCTET
[[/code]]

The message and command-size are defined by the ZMTP/3.0 grammar previously explained.

The body of the METADATA command consists of a list of properties consisting of name and value as size-specified strings.

The name SHALL be 1 to 255 characters. Zero-sized names are not valid. The case (upper or lower) of names SHALL NOT be significant.

The value SHALL be 0 to 2^31-1 octets of opaque binary data. Zero-sized values are allowed. The semantics of the value depend on the property. The value size field SHALL be four octets, in network byte order. Note that this size field will mostly not be aligned in memory.

++ Backwards Interoperability

To detect and work with older versions of ZMTP, we use a mix of strategies. An implementation MAY use any or all or none of these strategies.

+++ Detecting ZMTP/2.0 Peers

From ZMTP/2.0[((bibcite zmtp20))] onwards, the protocol contains the version number immediately after the signature. To detect and interoperate with ZMTP/2.0 peers, the implementation SHALL:

* Send the 10-octet signature followed by the major version number (the single octet %x03).

* Wait for the other peer to send its greeting.

* If this has the version number 1 or 2, the peer is using ZMTP/2.0, so send the ZMTP/2.0 socket type and identity and continue with ZMTP/2.0.

* If this has the version number 3, the peer is using ZMTP/3.0, so send the rest of the greeting and continue with ZMTP/3.0.

To work with ZMTP/2.0 peers the application must use only empty service names.

+++ Detecting ZMTP/1.0 Peers

ZMTP/1.0[((bibcite zmtp10))] did not have any version information. To detect and interoperate with a ZMTP/1.0 peer, an implementation SHALL:

* Send a 10-octet pseudo-signature consisting of "%xFF size %x7F" where 'size' is the number of octets in the sender's identity (0 or greater) plus 1. The size SHALL be 8 octets in network byte order and occupies the padding field.

* Read the first octet from the other peer.

* If this octet is not %FF, then the other peer is using ZMTP/1.0.

* If this octet is %FF, then we read nine further octets, and inspect the last octet (the 10th). If the least significant bit is 0, then the other peer is using ZMTP/1.0.

* If the least significant bit is not 0, the peer is using ZMTP/3.0 or a later version. We read a further octet, which indicates the protocol version. If this is 1 or 2, we have a ZMTP/2.0 peer. If this is 3, we have a ZMTP/3.0 peer.

* When we have detected a ZMTP/1.0 peer, we have already sent 10 octets, which the other peer interprets as the start of an identity frame. We continue by sending the body of the identity frame (zero or more octets). From then, we encode and decode all frames on that connection using the ZMTP/1.0 framing syntax.

To work with ZMTP/1.0 peers the application must use only empty service names.

++ Worked Example

A DEALER client connects to a "lookup" service on a ROUTER server. Both client and server are running ZMTP/3.0 and the implementation has backwards compatibility detection. The peers will use the NULL security mechanism to talk to each other.

* The client sends a partial greeting (11 octets) greeting to the server, and at the same time (before receiving anything from the client), the server also sends a partial greeting:

[[code]]
 signature                   major
+------+-------------+------+------+
| %xFF | %x00...%x00 | %x7F | %x03 |
+------+-------------+------+------+
   0        1 - 8       9      10
[[/code]]

* The client and server read the major version number (%x03) and send the rest of their greeting to each other:

[[code]]
 minor   service    options       mechanism
+------+----------+-------------+-----------+
| %x00 | "lookup" | %x00...%x00 | "NULL"    |
+------+----------+-------------+-----------+
   11    12 - 131    132 - 139    140 - 159
[[/code]]

* The client and server now perform the NULL security handshake. First the client sends a METADATA command to the server that specifies the socket type ("DEALER") and identity (empty) properties:

[[code]]
+------+----+
| %x04 | 45 |
+------+----+
   0     1
 flags  size
     
+---+---+---+---+---+---+---+---+
| M | E | T | A | D | A | T | A |
+---+---+---+---+---+---+---+---+
  2   3   4   5   6   7   8   9
 Command name "METADATA"
 
+----+---+---+---+---+---+---+---+---+---+---+---+
| 11 | S | o | c | k | e | t | - | T | y | p | e |
+----+---+---+---+---+---+---+---+---+---+---+---+
  10  11  12  13  14  15  16  17  18  19  20  21
 Property name "Socket-Type"

+------+------+------+------+---+---+---+---+---+---+
| %x00 | %x00 | %x00 | %x06 | D | E | A | L | E | R |
+------+------+------+------+---+---+---+---+---+---+
   22     23     24     25   26  27  28  29  30  31 
 Property value "DEALER"
   
+----+---+---+---+---+---+---+---+---+
| 8  | I | d | e | n | t | i | t | y |
+----+---+---+---+---+---+---+---+---+
  32  33  34  35  36  37  38  39  40
 Property name "Identity"
 
+------+------+------+------+
| %x00 | %x00 | %x00 | %x00 |
+------+------+------+------+
   41     42     43     44
 Property value ""
[[/code]]

* The server validates the socket type, accepts it, and replies with a METADATA command:

[[code]]
+------+----+
| %x04 | 45 |
+------+----+
+---+---+---+---+---+---+---+---+
| M | E | T | A | D | A | T | A |
+---+---+---+---+---+---+---+---+
+----+---+---+---+---+---+---+---+---+---+---+---+
| 11 | S | o | c | k | e | t | - | T | y | p | e |
+----+---+---+---+---+---+---+---+---+---+---+---+
+------+------+------+------+---+---+---+---+---+---+
| %x00 | %x00 | %x00 | %x06 | R | O | U | T | E | R |
+------+------+------+------+---+---+---+---+---+---+
+----+---+---+---+---+---+---+---+---+
| 8  | I | d | e | n | t | i | t | y |
+----+---+---+---+---+---+---+---+---+
+------+------+------+------+
| %x00 | %x00 | %x00 | %x00 |
+------+------+------+------+
[[/code]]

As soon as the server has sent its own METADATA command, it may also send messages to the client. As soon as the client has received the METADATA command from the server, it may send messages to the server.

++ Security Considerations

* Attackers may overwhelm a peer by repeated connection attempts. Thus, a peer MAY log failed accesses, and MAY detect and block repeated failed connections from specific originating IP addresses.

* Attackers may try to cause memory exhaustion in a peer by holding open connections. Thus, a peer MAY allocate memory to a connection only after the security handshake is complete, and MAY limit the number and cost of in-progress handshakes.

* Attackers may try to make small requests that generate large responses back to faked originating addresses (the real target of the attack). This is called an "amplification attack". Thus, peers MAY limit the number of in-progress handshakes per originating IP address.

* Attackers may try to uncover vulnerable versions of an implementation from its metadata. Thus, ZMTP/3.0 sends metadata //after// security handshaking.

* Attackers can use the size of messages (even without breaking encryption) to collect information about the meaning. Thus, on an encrypted connection, message data SHOULD be padded to a randomized minimum size.

* Attackers can use the simple presence or absence of traffic to collect information about the peer ("Person X has come on line"). Thus, on an encrypted connection, the peer SHOULD send random garbage data ("noise") when there is no other traffic. To fully mask traffic, a peer MAY throttle messages so there is no visible difference between noise and real data.

++ References

[[bibliography]]
: rfc2119 : "Key words for use in RFCs to Indicate Requirement Levels" - [http://tools.ietf.org/html/rfc2119 ietf.org]
: rfc4422 : "Simple Authentication and Security Layer" - [http://tools.ietf.org/html/rfc4422 ietf.org]
: fandos : "Definition of a Free and Open Standard" - [http://www.digistan.org/open-standard:definition digistan.org]
: coss : "Consensus Oriented Specification System" - [http://www.digistan.org/spec:1/COSS digistan.org]
: zmtp10 : "13/ZMTP - ZeroMQ Message Transport Protocol" - [http://rfc.zeromq.org/spec:13 rfc.zeromq.org]
: zmtp20 : "15/ZMTP - ZeroMQ Message Transport Protocol" - [http://rfc.zeromq.org/spec:15 rfc.zeromq.org]
: curvezmq : "The CurveZMQ Secure Handshake" - [http://curvezmq.org curvezmq.org]
[[/bibliography]]
